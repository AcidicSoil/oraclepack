Direct answer (caching opportunities/risks; keys; invalidation; correctness)

Ticket discovery cache: Step 01’s .oraclepack/ticketify/_tickets_index.json is a natural deterministic cache of “what tickets exist + extracted metadata.” Cache key = hash of all ticket file paths+contents under the discovered roots (notably .tickets/), plus discovery algorithm/version, plus run CWD (since steps run in project root and oraclepack does not chdir to out_dir). Invalidate on any ticket add/remove/edit/rename, discovery logic change, or different root/CWD. Correctness risk: stale index leads to downstream actions/PRD being generated against the wrong ticket set; missing .tickets/ is a known failure point. 

Oraclepack_Compatibility_Issues

Action synthesis cache: Step 02’s _actions.json + _actions.md can be cached as a pure function of _tickets_index.json + the prompt/template used to derive actions. Cache key = _tickets_index.json content hash + “actions prompt/template version” + toolchain identity (e.g., oracle CLI flags if oracle is used here). Invalidate if tickets index changes, prompt/template changes, or toolchain flags change. Correctness risk: reusing _actions.json after tickets change causes Step 09 selection and Step 10 implementation to target obsolete work.

Task Master derived artifacts cache: Step 03 .taskmaster/docs/tickets_prd.md and Steps 05–07 outputs (including .oraclepack/ticketify/tm-complexity.json) are expensive and can be cached with key = _actions.json hash + Task Master version/config + PRD generation prompt/template. Invalidate on _actions.json change, Task Master upgrade/config change, or PRD template change. Correctness risk: stale complexity/expanded tasks drives “agent-mode” (post-expansion) to implement the wrong tasks.

“Next target” selection cache: Step 09’s .oraclepack/ticketify/next.json should be treated as a cacheable decision record. Cache key = _actions.json hash + repo state fingerprint (recommended: git rev-parse HEAD + git diff hash) + selection heuristic version. Invalidate on actions change or repo state change. Correctness risk: using an old next.json after code changes can produce irrelevant patches or merge conflicts in Step 10.

Codex/Gemini implementation/review outputs cache: Step 10 .oraclepack/ticketify/codex-implement.md and Step 11 .oraclepack/ticketify/codex-verify.md / .oraclepack/ticketify/gemini-review.json should be cached only as immutable run artifacts, not as reusable inputs, unless the repo-state key matches exactly. Cache key = next.json hash + repo-state fingerprint + codex/gemini invocation flags + tool versions. Invalidate on any mismatch. Correctness risk: reusing “implementation” content across different repo states can apply incorrect changes; interactivity/availability are known failure modes, so caches must not mask missing-tool failures.

Oracle command output cache (per-step --write-output): each oracle invocation’s output markdown is cacheable if (and only if) inputs are fully captured. Cache key = (full prompt string, including embedded strategist question) + ordered list of attached files with content hashes + oracle flags (the injected/overridden flags matter) + oracle CLI version/engine/model selection. Invalidate on any of those changing. Correctness risk: if override injection changes the effective flags but the cache key only uses the pre-injection command string, you can serve the wrong output.
